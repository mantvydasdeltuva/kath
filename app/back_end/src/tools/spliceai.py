"""
spliceai_module.py

This module provides functionality to work with SpliceAI, a tool for predicting the
effects of genetic variants on splicing. It includes functions to create VCF files
from variant data, run the SpliceAI tool on these files, parse the results, and
enhance data with SpliceAI evaluation scores.

Functions:
- write_vcf(data: pd.DataFrame) -> str:
    Creates a temporary VCF file from a given DataFrame containing variant information.

- run_spliceai(input_vcf: str, fasta: str, distance: int = 50, annotation: str = "grch38") -> str:
    Executes SpliceAI on the provided VCF file and produces an output VCF file with predictions.

- parse_spliceai_vcf(vcf_file: str) -> list:
    Parses the output VCF file generated by SpliceAI and extracts relevant scores.

- add_spliceai_eval_columns(data: pd.DataFrame, fasta_path: str) -> pd.DataFrame:
    Enhances the provided DataFrame with SpliceAI evaluation columns based on variant predictions.

Custom Exceptions:
- SpliceAIError: Custom exception class for handling errors specific to SpliceAI operations.

Dependencies:
- pandas: For data manipulation and DataFrame handling.
- subprocess: For executing external commands (SpliceAI).
- os: For file path operations and cleanup.
- tempfile: For creating temporary files.

Usage:
To use this module, import it and call the relevant functions, providing the necessary
inputs such as DataFrames containing variant information and paths to required files.

Example:
    import pandas as pd
    from spliceai_module import add_spliceai_eval_columns

    # Load your variant data into a DataFrame
    variant_data = pd.read_csv("variants.csv")

    # Run SpliceAI evaluation
    enhanced_data = add_spliceai_eval_columns(variant_data, "reference.fasta")
"""
import os
import subprocess
import pandas as pd
from datetime import datetime



class SpliceAIError(Exception):
    """Custom exception for SpliceAI errors."""


def parse_variant(variant_str):
    """
    Parses a variant string and extracts chromosome, position, reference, and alternative alleles.

    The function takes a variant string in the format of `chrom-pos-ref-alt` (e.g., `1-123-A-G`), 
    and splits it into the individual components. If the string contains only chromosome and position 
    (e.g., `1-123`), it will assume reference and alternative alleles as missing (represented by `"."`).

    Args:
        variant_str (str): The variant string to be parsed, typically in the format `chrom-pos-ref-alt`.

    Returns:
        tuple: A tuple containing:
            - chrom (str): The chromosome part of the variant string.
            - pos (str): The position part of the variant string.
            - ref (str): The reference allele (or `"."` if not provided).
            - alt (str): The alternative allele (or `"."` if not provided).

    Example:
        parse_variant("1-123-A-G")  -> ('1', '123', 'A', 'G')
        parse_variant("1-123")      -> ('1', '123', '.', '.')
    """
    try:
        chrom, pos, ref, alt = variant_str.split("-")
        return chrom, pos, ref, alt
    except ValueError:
        chrom, pos, _ = variant_str.split("-")
        return chrom, pos, ".", "."
    except AttributeError:
        return ".", ".", ".", "."


def write_vcf(dataframe:pd.DataFrame, output_filename:str)-> str:
    """
    Writes a VCF (Variant Call Format) file without header
    from the given DataFrame.

    This function extracts specific variant information
    from a pandas DataFrame and writes it to a VCF file.
    For each row, the function extracts the first valid variant value 
    found in these columns, parses it, and writes the corresponding VCF line.

    Args:
        dataframe (pd.DataFrame): The DataFrame containing the variant data.
        output_filepath (str): The path where the VCF file will be saved.

    Returns:
        str: The file path where the VCF file has been written.
    """
    today_date = datetime.today().strftime("%Y%m%d")
    header = (
        "##fileformat=VCFv4.2\n"
        f"##fileDate={today_date}\n"
        "##reference=GRCh38\n"
        "##contig=<ID=6,length=171115067>\n"
        "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n"
    )
    with open(output_filename, 'w') as f:
        f.write(header)
        variant_columns = ["hg38_gnomad_format", "variant_id_gnomad","variant_id", "hg38_ID_clinvar"]
        for _, row in dataframe.iterrows():
            variant_value = None
            for col in variant_columns:
                if col in row and pd.notna(row[col]) and row[col]!="?":
                    variant_value = row[col]
                    break
            chrom, pos, ref, alt = parse_variant(variant_value)
            vcf_line = f"{chrom}\t{pos}\t.\t{ref}\t{alt}\t.\t.\t.\n"
            f.write(vcf_line) 
    return output_filename  
    


def run_spliceai(input_vcf: str, ouput_vcf: str, fasta: str, distance=50, annotation="grch38"):
    """
    Runs SpliceAI on the provided VCF file.

    This function constructs and executes a SpliceAI command to analyze
    the variants in the input VCF file and writes the results to a
    output VCF file.

    Args:
        input_vcf (str): Path to the input VCF file.
        ouput_vcf (str): Path to the ouput VCF file.
        fasta (str): Path to the reference genome file in FASTA format.
        distance (int): The distance parameter for SpliceAI (default is 50).
        annotation (str): Annotation type (default is "grch38").

    Returns:
        str: Path to the output VCF file created.

    Raises:
        SpliceAIError: If the FASTA file is not found or if SpliceAI execution fails.
    """
    if not os.path.isfile(fasta):
        raise SpliceAIError(f"FASTA file not found: {fasta}")
    
    with open(ouput_vcf, 'w') as output_vcf:
        spliceai_command = [
            "spliceai",
            "-I", input_vcf,
            "-O", ouput_vcf,
            "-R", fasta,
            "-D", str(distance),
            "-A", annotation
        ]

        try:
            result = subprocess.run(spliceai_command, capture_output=True, text=True, check=True)
            if result.returncode != 0:
                raise SpliceAIError(f"SpliceAI failed: {result.stderr}")
        except Exception as exc:
            raise SpliceAIError(f"Error running SpliceAI: {exc}") from exc


def parse_spliceai_vcf(vcf_file: str):
    """
    Parses the output VCF file generated by SpliceAI.

    This function extracts the SpliceAI scores from the output VCF file
    and returns them as a list of dictionaries.

    Args:
        vcf_file (str): Path to the VCF file with SpliceAI predictions.

    Returns:
        list: A list of dictionaries containing extracted scores for each variant.

    Raises:
        SpliceAIError: If there is an error while reading or parsing the VCF file.
    """
    spliceai_scores = []
    try:
        with open(vcf_file, 'r',encoding='utf-8') as vcf:
            for line in vcf:
                if line.startswith('#'):
                    continue
                columns = line.strip().split('\t')
                info_field = columns[7]
                info_parts = info_field.split(";")
                for part in info_parts:
                    if part.startswith("SpliceAI="):
                        spliceai_values = part.split("=")[1]
                        delta_scores = spliceai_values.split("|")

                        ds_ag = float(delta_scores[2])
                        ds_al = float(delta_scores[3])
                        ds_dg = float(delta_scores[4])
                        ds_dl = float(delta_scores[5])

                        max_delta_score = max(ds_ag, ds_al, ds_dg, ds_dl)

                        dp_ag = int(delta_scores[6])
                        dp_al = int(delta_scores[7])
                        dp_dg = int(delta_scores[8])
                        dp_dl = int(delta_scores[9])

                        scores = {
                            "Delta score (acceptor gain)": ds_ag,
                            "Delta score (acceptor loss)": ds_al,
                            "Delta score (donor gain)": ds_dg,
                            "Delta score (donor loss)": ds_dl,
                            "Delta position (acceptor gain)": int(columns[1]) + dp_ag,
                            "Delta position (acceptor loss)": int(columns[1]) + dp_al,
                            "Delta position (donor gain)": int(columns[1]) + dp_dg,
                            "Delta position (donor loss)": int(columns[1]) + dp_dl,
                            "Max_Delta_Score": max_delta_score
                        }
                    else:
                        scores = {
                            "Delta score (acceptor gain)": None,
                            "Delta score (acceptor loss)": None,
                            "Delta score (donor gain)": None,
                            "Delta score (donor loss)": None,
                            "Delta position (acceptor gain)": None,
                            "Delta position (acceptor loss)": None,
                            "Delta position (donor gain)": None,
                            "Delta position (donor loss)": None,
                            "Max_Delta_Score": None
                        }
                    spliceai_scores.append(scores)
        return spliceai_scores
    except Exception as e:
        raise ValueError(f"Error parsing VCF file {vcf_file}: {e}") from e


def add_spliceai_eval_columns(data: pd.DataFrame, fasta_path: str,spliceai_dir:str) -> pd.DataFrame:
    """
    Adds columns for SpliceAI evaluation to the DataFrame with a _spliceai postfix.

    This function orchestrates the VCF writing, SpliceAI execution, and
    parsing of the results to enhance the original DataFrame with SpliceAI
    scores.

    Args:
        data (pd.DataFrame): DataFrame containing original variant information.
        fasta_path (str): Path to the reference genome file in FASTA format.

    Returns:
        pd.DataFrame: DataFrame enriched with SpliceAI evaluation columns.

    Raises:
        SpliceAIError: If any error occurs during the VCF processing or
                        SpliceAI execution.
    """
    spliceai_input_vcf=os.path.join(spliceai_dir, "spliceai_input.vcf")
    spliceai_output_vcf=os.path.join(spliceai_dir, "spliceai_output.vcf")
    data_copy = data.copy()
    input_vcf = write_vcf(data_copy,spliceai_input_vcf)
    run_spliceai(input_vcf,spliceai_output_vcf, fasta_path)
    spliceai_scores = parse_spliceai_vcf(spliceai_output_vcf)

    scores_df = pd.DataFrame(spliceai_scores)
    scores_df.columns = [f"{col}_spliceai" for col in scores_df.columns]
    data_copy = pd.concat([data_copy,
                            scores_df], axis=1)
    return data_copy
